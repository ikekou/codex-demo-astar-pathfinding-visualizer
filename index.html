<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>A* Pathfinding Visualizer (Single File)</title>
  <style>
    /* --- Basic Layout --- */
    :root {
      --bg: #0e1322;
      --panel: #141a2e;
      --panel-2: #1b2340;
      --text: #e9ecf5;
      --muted: #a6adc8;
      --accent: #7aa2ff;
      --good: #4cc38a;
      --bad: #f16a6f;
      --warn: #ffd76a;
      --grid: #2b3255;
      --open: #7cd3ff;
      --closed: #6c7a89;
      --path: #ffd76a;
      --wall: #0f1220;
      --header-h: 60px;
    }

    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans JP", "Hiragino Sans", "Yu Gothic UI", sans-serif;
    }

    .header {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
      padding: 10px 14px;
      background: linear-gradient(0deg, var(--panel), var(--panel-2));
      border-bottom: 1px solid #252b4a;
      position: sticky;
      top: 0;
      z-index: 10;
    }

    .group { display: flex; gap: 8px; align-items: center; }
    .group label { color: var(--muted); font-size: 12px; }
    .group input[type="range"] { width: 140px; }

    button, select {
      background: #222848;
      color: var(--text);
      border: 1px solid #2f365b;
      border-radius: 6px;
      padding: 6px 10px;
      cursor: pointer;
      transition: transform 0.05s ease, border-color 0.2s ease, background 0.2s ease;
    }
    button:hover { border-color: #43508b; transform: translateY(-1px); }
    button.primary { background: var(--accent); color: #0b1026; border-color: transparent; }
    button.danger { background: #ef5350; color: #fff; border-color: transparent; }

    .container {
      padding: 14px;
      display: grid;
      grid-template-rows: auto 1fr;
      gap: 10px;
      height: calc(100vh - var(--header-h));
      box-sizing: border-box;
    }

    .canvas-wrap {
      display: grid;
      place-items: center;
      height: 100%;
      background:
        linear-gradient(transparent 23px, rgba(255,255,255,0.04) 24px),
        linear-gradient(90deg, transparent 23px, rgba(255,255,255,0.04) 24px);
      background-size: 24px 24px;
      border: 1px solid #242a49;
      border-radius: 10px;
    }

    canvas { 
      background: #0b0f20; 
      border-radius: 8px;
      image-rendering: pixelated;
      width: 100%;
      height: 100%;
      max-width: 100%;
      max-height: 100%;
    }

    .legend { display: flex; gap: 14px; color: var(--muted); font-size: 12px; flex-wrap: wrap; }
    .dot { width: 12px; height: 12px; display: inline-block; border-radius: 3px; margin-right: 6px; vertical-align: middle; }
    .msg { color: var(--muted); min-height: 1.4em; }
    .msg.error { color: var(--bad); }
    .msg.success { color: var(--good); }
    /* Help modal and fullscreen adjustments */
    .modal-backdrop { position: fixed; inset: 0; background: rgba(8,10,18,0.6); display: flex; align-items: center; justify-content: center; padding: 14px; }
    .modal { background: var(--panel); border: 1px solid #2a3158; border-radius: 10px; padding: 14px; max-width: 680px; width: 100%; box-shadow: 0 10px 30px rgba(0,0,0,0.4); }
    :fullscreen .canvas-wrap { border-radius: 0; }
  </style>
</head>
<body>
  <!-- Header: Controls -->
  <div class="header">
    <div class="group">
      <button id="run" class="primary" title="探索を開始します">Run</button>
      <button id="pause" title="探索を一時停止します">Pause</button>
      <button id="step" title="1ステップだけ進めます（デバッグ用）">Step</button>
      <button id="reset" title="グリッドを初期化して再生成します">Reset Grid</button>
      <button id="clearWalls" title="すべての壁を削除します">Clear Walls</button>
      <button id="randomWalls" title="ランダムに壁を生成します">Random Walls</button>
    </div>
    <div class="group">
      <label title="小さいほどゆっくり・大きいほど速い">Speed</label>
      <input id="speed" type="range" min="1" max="120" value="30" title="1=ゆっくり / 120=高速" />
    </div>
    <div class="group">
      <label title="行数（縦のマス数）">Rows</label>
      <input id="rows" type="range" min="10" max="60" value="25" title="行数（縦のマス数）" />
      <label title="列数（横のマス数）">Cols</label>
      <input id="cols" type="range" min="10" max="80" value="40" title="列数（横のマス数）" />
    </div>
    <div class="group">
      <label title="操作モードの切替">Mode</label>
      <select id="mode" title="壁の描画/消去、Start/Goalの移動を切替">
        <option value="wall">Draw Walls</option>
        <option value="erase">Erase</option>
        <option value="start">Move Start</option>
        <option value="goal">Move Goal</option>
      </select>
    </div>
    <div class="group">
      <label title="斜め方向の移動を許可"><input id="diagonal" type="checkbox" /> Diagonal</label>
    </div>
    <div class="group">
      <button id="save" title="現在の配置をローカルに保存">Save</button>
      <button id="load" title="保存した配置を読み込み">Load</button>
    </div>
    <div class="group" style="margin-left:auto">
      <button id="fullscreenBtn" title="描画領域をフルスクリーン表示">Fullscreen</button>
      <button id="helpBtn" title="使い方を表示">Help</button>
    </div>
  </div>

  <div class="container">
    <div class="legend">
      <span><span class="dot" style="background: var(--grid)"></span>Grid</span>
      <span><span class="dot" style="background: var(--wall)"></span>Wall</span>
      <span><span class="dot" style="background: var(--open)"></span>Open</span>
      <span><span class="dot" style="background: var(--closed)"></span>Closed</span>
      <span><span class="dot" style="background: var(--path)"></span>Path</span>
      <span><span class="dot" style="background: var(--good)"></span>Start</span>
      <span><span class="dot" style="background: var(--bad)"></span>Goal</span>
      <span class="msg" id="status"></span>
    </div>
    <div class="canvas-wrap">
      <canvas id="canvas" width="960" height="600"></canvas>
    </div>
  </div>

  <!-- Help Modal -->
  <div id="helpModal" class="modal-backdrop" style="display:none">
    <div class="modal">
      <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;">
        <h2 style="margin:0;font-size:18px;">使い方</h2>
        <button id="helpClose" title="閉じる">×</button>
      </div>
      <div style="font-size:14px;color:var(--muted);line-height:1.7;margin-top:8px;">
        <p><strong>基本</strong>: グリッド上でドラッグして <em>壁</em> を描画します。<br/>Mode を <em>Move Start</em>/<em>Move Goal</em> に切り替えると、開始/終了位置を移動できます。</p>
        <p><strong>実行</strong>: 壁を配置したら <em>Run</em> で探索開始、<em>Pause</em> で一時停止、<em>Step</em> で1手だけ進めます。<br/>斜め移動は <em>Diagonal</em> でON/OFF。速度は <em>Speed</em> スライダーで調整。</p>
        <p><strong>サイズ変更</strong>: <em>Rows</em>/<em>Cols</em> を動かすと、行・列サイズを変更してグリッドを再生成します。</p>
        <p><strong>保存/読込</strong>: <em>Save</em> で現在の状態をブラウザに保存、<em>Load</em> で復元します。</p>
        <p><strong>色の意味</strong>: 緑=Start / 赤=Goal / 黄=Path / 水色=Open / グレー=Closed / 暗色=Wall。</p>
        <p><strong>到達不可</strong>: 経路がない場合、上部のステータスに「経路が見つかりませんでした。」と表示されます。</p>
        <p style="margin:6px 0 0;color:var(--text);">ヒント: まずは壁を少し描いて Run を押してください。</p>
      </div>
    </div>
  </div>

  <script>
    // A* Pathfinding Visualizer - Single-file implementation
    // No external dependencies. Inline HTML/CSS/JS.

    // ----- Data Structures -----
    /** Node structure for each grid cell */
    class Node {
      constructor(r, c) {
        this.r = r; // row
        this.c = c; // col
        this.wall = false; // is obstacle
        this.g = Infinity; // cost from start
        this.h = 0;        // heuristic to goal
        this.f = Infinity; // g + h
        this.prev = null;  // previous node in path
        this.inOpen = false;
        this.inClosed = false;
      }
    }

    // ----- Globals -----
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const statusEl = document.getElementById('status');

    const runBtn = document.getElementById('run');
    const pauseBtn = document.getElementById('pause');
    const stepBtn = document.getElementById('step');
    const resetBtn = document.getElementById('reset');
    const clearWallsBtn = document.getElementById('clearWalls');
    const randomWallsBtn = document.getElementById('randomWalls');
    const speedInput = document.getElementById('speed');
    const rowsInput = document.getElementById('rows');
    const colsInput = document.getElementById('cols');
    const modeSelect = document.getElementById('mode');
    const diagonalCheckbox = document.getElementById('diagonal');
    const saveBtn = document.getElementById('save');
    const loadBtn = document.getElementById('load');
    const helpBtn = document.getElementById('helpBtn');
    const helpModal = document.getElementById('helpModal');
    const helpClose = document.getElementById('helpClose');
    const fullscreenBtn = document.getElementById('fullscreenBtn');
    const canvasWrap = document.querySelector('.canvas-wrap');

    const STORAGE_KEY = 'astar-visualizer-v1';

    let rows = parseInt(rowsInput.value, 10);
    let cols = parseInt(colsInput.value, 10);
    let grid = [];              // 2D array of Node
    let startNode = null;       // Node
    let goalNode = null;        // Node
    let openHeap = null;        // Min-heap for open set
    let running = false;
    let paused = true;
    let stepsPerFrame = parseInt(speedInput.value, 10);
    let dragging = false;
    let dragMove = false; // when moving start/goal
    let lastDragCell = null;
    let path = [];

    // ----- Utilities -----
    function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }

    function resetAlgoState() {
      // Reset node costs and sets
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const n = grid[r][c];
          n.g = Infinity; n.h = 0; n.f = Infinity; n.prev = null; n.inOpen = false; n.inClosed = false;
        }
      }
      if (!openHeap) openHeap = new MinHeap((a, b) => a.f - b.f);
      openHeap.clear();
      path = [];
      paused = true;
      running = false;
      setStatus('Ready. Click Run to start.');
    }

    function setStatus(text, type = '') {
      statusEl.textContent = ' — ' + text;
      statusEl.className = 'msg ' + type;
    }

    function deviceScaleCanvas() {
      // Improve sharpness on HiDPI screens
      const ratio = window.devicePixelRatio || 1;
      const cssWidth = canvas.clientWidth || canvas.width;
      const cssHeight = canvas.clientHeight || canvas.height;
      canvas.width = Math.floor(cssWidth * ratio);
      canvas.height = Math.floor(cssHeight * ratio);
      ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
    }

    function layoutCanvas() {
      // Ensure the canvas fills the available wrapper space
      const wrapRect = canvasWrap.getBoundingClientRect();
      canvas.style.width = Math.max(300, Math.floor(wrapRect.width)) + 'px';
      canvas.style.height = Math.max(240, Math.floor(wrapRect.height)) + 'px';
    }

    // ----- Core: Grid Init & Drawing -----
    function initGrid() {
      rows = parseInt(rowsInput.value, 10);
      cols = parseInt(colsInput.value, 10);

      grid = new Array(rows);
      for (let r = 0; r < rows; r++) {
        grid[r] = new Array(cols);
        for (let c = 0; c < cols; c++) grid[r][c] = new Node(r, c);
      }

      // Default start/goal positions near center
      startNode = grid[Math.floor(rows / 2)][Math.floor(cols / 4)];
      goalNode = grid[Math.floor(rows / 2)][Math.floor(cols * 3 / 4)];

      resetAlgoState();
      layoutCanvas();
      draw();
    }

    function draw() {
      deviceScaleCanvas();
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const cw = canvas.clientWidth || canvas.width;
      const ch = canvas.clientHeight || canvas.height;
      const cellW = Math.floor(cw / cols);
      const cellH = Math.floor(ch / rows);
      const size = Math.max(5, Math.floor(Math.min(cellW, cellH)));

      // Background
      ctx.fillStyle = '#0d1020';
      ctx.fillRect(0, 0, cw, ch);

      // Cache CSS colors once per draw
      const css = getComputedStyle(document.documentElement);
      const colWall   = css.getPropertyValue('--wall');
      const colGood   = css.getPropertyValue('--good');
      const colBad    = css.getPropertyValue('--bad');
      const colClosed = css.getPropertyValue('--closed');
      const colOpen   = css.getPropertyValue('--open');
      const colGrid   = css.getPropertyValue('--grid');
      const colPath   = css.getPropertyValue('--path');

      // Draw cells
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const n = grid[r][c];
          const x = c * size; const y = r * size;
          if (n.wall) {
            ctx.fillStyle = colWall;
          } else if (n === startNode) {
            ctx.fillStyle = colGood;
          } else if (n === goalNode) {
            ctx.fillStyle = colBad;
          } else if (n.inClosed) {
            ctx.fillStyle = colClosed;
          } else if (n.inOpen) {
            ctx.fillStyle = colOpen;
          } else {
            ctx.fillStyle = colGrid;
          }
          ctx.fillRect(x, y, size - 1, size - 1);
        }
      }

      // Draw current path on top
      if (path && path.length) {
        ctx.fillStyle = colPath;
        for (const n of path) {
          const x = n.c * size; const y = n.r * size;
          ctx.fillRect(x, y, size - 1, size - 1);
        }
      }
    }

    // ----- A* Implementation -----
    function heuristic(a, b) {
      // Manhattan for 4-dir; Octile for 8-dir
      const dr = Math.abs(a.r - b.r);
      const dc = Math.abs(a.c - b.c);
      if (!diagonalCheckbox.checked) return dr + dc;
      const F = Math.SQRT2 - 1; // octile coefficient
      return (dr < dc) ? F * dr + dc : F * dc + dr;
    }

    function neighbors(node) {
      const res = [];
      const d4 = [ [1,0], [-1,0], [0,1], [0,-1] ];
      const d8 = [ [1,1], [1,-1], [-1,1], [-1,-1] ];
      for (const [dr, dc] of d4) {
        const r = node.r + dr, c = node.c + dc;
        if (r>=0 && r<rows && c>=0 && c<cols) res.push(grid[r][c]);
      }
      if (diagonalCheckbox.checked) {
        for (const [dr, dc] of d8) {
          const r = node.r + dr, c = node.c + dc;
          if (r>=0 && r<rows && c>=0 && c<cols) res.push(grid[r][c]);
        }
      }
      return res;
    }

    function reconstructPath(endNode) {
      const p = [];
      let cur = endNode;
      while (cur) { p.push(cur); cur = cur.prev; }
      p.reverse();
      return p;
    }

    function prepareAStar() {
      // Initialize for a new run
      resetAlgoState();
      startNode.g = 0;
      startNode.h = heuristic(startNode, goalNode);
      startNode.f = startNode.h;
      openHeap.push(startNode);
      startNode.inOpen = true;
    }

    function stepAStar() {
      if (openHeap.size() === 0) {
        // No path
        running = false;
        paused = true;
        setStatus('経路が見つかりませんでした。', 'error');
        return 'done';
      }

      // Pop node with the lowest f
      const current = openHeap.pop();
      current.inOpen = false;
      current.inClosed = true;

      if (current === goalNode) {
        path = reconstructPath(current);
        running = false;
        paused = true;
        setStatus(`経路長: ${path.length}（到達）`, 'success');
        return 'done';
      }

      // Explore neighbors
      for (const nb of neighbors(current)) {
        if (nb.wall || nb.inClosed) continue;
        const cost = (nb.r !== current.r && nb.c !== current.c) ? Math.SQRT2 : 1;
        const tentativeG = current.g + cost;
        if (tentativeG < nb.g) {
          nb.prev = current;
          nb.g = tentativeG;
          nb.h = heuristic(nb, goalNode);
          nb.f = nb.g + nb.h;
          if (!nb.inOpen) { openHeap.push(nb); nb.inOpen = true; }
          else { openHeap.update(nb); }
      }
      }

      // Update preview path for nicer visualization
      const peek = openHeap.peek();
      if (peek) path = reconstructPath(peek);

      return 'continue';
    }

    function runAStar() {
      if (!startNode || !goalNode) return;
      if (!running) { prepareAStar(); running = true; }
      paused = false;
      setStatus('探索中…');

      const loop = () => {
        if (paused) return; // stop the loop
        let count = clamp(parseInt(speedInput.value, 10), 1, 240);
        const frameStart = performance.now();
        while (count-- > 0 && !paused) {
          const res = stepAStar();
          if (res === 'done') break;
          // Keep frame under ~12ms to remain smooth (~60fps)
          if (performance.now() - frameStart > 12) break;
        }
        draw();
        if (!paused) requestAnimationFrame(loop);
      };
      requestAnimationFrame(loop);
    }

    // ----- MinHeap Implementation (binary heap) -----
    function MinHeap(compare) {
      this.arr = [];
      this.compare = compare || ((a, b) => a - b);
    }
    MinHeap.prototype.size = function() { return this.arr.length; };
    MinHeap.prototype.clear = function() {
      for (const x of this.arr) if (x) x.heapIndex = -1;
      this.arr.length = 0;
    };
    MinHeap.prototype.peek = function() { return this.arr[0] || null; };
    MinHeap.prototype.push = function(item) {
      item.heapIndex = this.arr.length;
      this.arr.push(item);
      this._siftUp(item.heapIndex);
    };
    MinHeap.prototype.pop = function() {
      const n = this.arr.length; if (!n) return null;
      const top = this.arr[0];
      const last = this.arr.pop();
      if (n > 1 && last) {
        this.arr[0] = last; last.heapIndex = 0; this._siftDown(0);
      }
      if (top) top.heapIndex = -1;
      return top || null;
    };
    MinHeap.prototype.update = function(item) {
      const i = item.heapIndex;
      if (i == null || i < 0 || i >= this.arr.length) return;
      if (!this._siftUp(i)) this._siftDown(i);
    };
    MinHeap.prototype._siftUp = function(i) {
      const a = this.arr; const cmp = this.compare; let moved = false;
      while (i > 0) {
        const p = (i - 1) >> 1;
        if (cmp(a[i], a[p]) < 0) { this._swap(i, p); i = p; moved = true; }
        else break;
      }
      return moved;
    };
    MinHeap.prototype._siftDown = function(i) {
      const a = this.arr; const cmp = this.compare; const n = a.length;
      while (true) {
        const l = i * 2 + 1, r = l + 1; let m = i;
        if (l < n && cmp(a[l], a[m]) < 0) m = l;
        if (r < n && cmp(a[r], a[m]) < 0) m = r;
        if (m !== i) { this._swap(i, m); i = m; } else break;
      }
    };
    MinHeap.prototype._swap = function(i, j) {
      const a = this.arr;
      const t = a[i]; a[i] = a[j]; a[j] = t;
      if (a[i]) a[i].heapIndex = i;
      if (a[j]) a[j].heapIndex = j;
    };

    // ----- Persistence -----
    function saveToLocalStorage() {
      const data = {
        rows, cols,
        diagonal: diagonalCheckbox.checked,
        start: { r: startNode.r, c: startNode.c },
        goal: { r: goalNode.r, c: goalNode.c },
        walls: [],
      };
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) if (grid[r][c].wall) data.walls.push([r, c]);
      }
      localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
      setStatus('保存しました。');
    }

    function loadFromLocalStorage() {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) { setStatus('保存データがありません。'); return; }
      try {
        const data = JSON.parse(raw);
        rowsInput.value = data.rows; colsInput.value = data.cols;
        diagonalCheckbox.checked = !!data.diagonal;
        initGrid();
        // Restore walls
        if (Array.isArray(data.walls)) {
          for (const [r, c] of data.walls) {
            if (r>=0 && r<rows && c>=0 && c<cols) grid[r][c].wall = true;
          }
        }
        // Restore start/goal
        if (data.start) startNode = grid[clamp(data.start.r,0,rows-1)][clamp(data.start.c,0,cols-1)];
        if (data.goal)  goalNode  = grid[clamp(data.goal.r,0,rows-1)][clamp(data.goal.c,0,cols-1)];
        resetAlgoState();
        draw();
        setStatus('読み込みました。');
      } catch (e) {
        console.error(e); setStatus('読み込みに失敗しました。', 'error');
      }
    }

    // ----- Interaction -----
    function canvasToCell(x, y) {
      const rect = canvas.getBoundingClientRect();
      const cx = x - rect.left; const cy = y - rect.top;
      const cellW = Math.floor((canvas.clientWidth || canvas.width) / cols);
      const cellH = Math.floor((canvas.clientHeight || canvas.height) / rows);
      const size = Math.max(5, Math.floor(Math.min(cellW, cellH)));
      const c = clamp(Math.floor(cx / size), 0, cols - 1);
      const r = clamp(Math.floor(cy / size), 0, rows - 1);
      return grid[r][c];
    }

    function handleDrawAt(node) {
      if (!node || node === startNode || node === goalNode) return;
      const mode = modeSelect.value;
      if (mode === 'wall') node.wall = true;
      else if (mode === 'erase') node.wall = false;
    }

    function handleMoveSpecial(node) {
      if (!node) return;
      const mode = modeSelect.value;
      if (mode === 'start' && node !== goalNode && !node.wall) startNode = node;
      if (mode === 'goal'  && node !== startNode && !node.wall) goalNode = node;
    }

    canvas.addEventListener('mousedown', (e) => {
      dragging = true; lastDragCell = null; dragMove = false;
      const cell = canvasToCell(e.clientX, e.clientY);
      if (modeSelect.value === 'start' || modeSelect.value === 'goal') { dragMove = true; handleMoveSpecial(cell); }
      else handleDrawAt(cell);
      resetAlgoState(); // any edit cancels current run
      draw();
      e.preventDefault();
    });
    canvas.addEventListener('mousemove', (e) => {
      if (!dragging) return;
      const cell = canvasToCell(e.clientX, e.clientY);
      if (cell === lastDragCell) return;
      lastDragCell = cell;
      if (dragMove) handleMoveSpecial(cell);
      else handleDrawAt(cell);
      resetAlgoState();
      draw();
    });
    window.addEventListener('mouseup', () => { dragging = false; dragMove = false; lastDragCell = null; });

    // Controls
    runBtn.addEventListener('click', runAStar);
    pauseBtn.addEventListener('click', () => { paused = true; setStatus('一時停止'); });
    stepBtn.addEventListener('click', () => {
      if (!running) prepareAStar();
      paused = true;
      const res = stepAStar();
      draw();
      if (res === 'done') paused = true;
    });
    resetBtn.addEventListener('click', () => { initGrid(); setStatus('グリッドをリセットしました。'); });
    clearWallsBtn.addEventListener('click', () => {
      for (let r = 0; r < rows; r++) for (let c = 0; c < cols; c++) grid[r][c].wall = false; 
      resetAlgoState(); draw(); setStatus('壁をクリアしました。');
    });
    randomWallsBtn.addEventListener('click', () => {
      const density = 0.22; // simple random density
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const n = grid[r][c];
          if (n === startNode || n === goalNode) { n.wall = false; continue; }
          n.wall = Math.random() < density;
        }
      }
      resetAlgoState(); draw(); setStatus('ランダムに壁を生成しました。');
    });

    rowsInput.addEventListener('input', () => { initGrid(); setStatus('行数変更: ' + rowsInput.value); });
    colsInput.addEventListener('input', () => { initGrid(); setStatus('列数変更: ' + colsInput.value); });
    diagonalCheckbox.addEventListener('change', () => { resetAlgoState(); draw(); setStatus(diagonalCheckbox.checked ? '斜め移動: ON' : '斜め移動: OFF'); });
    speedInput.addEventListener('input', () => { stepsPerFrame = parseInt(speedInput.value, 10); });

    saveBtn.addEventListener('click', saveToLocalStorage);
    loadBtn.addEventListener('click', loadFromLocalStorage);

    // Help modal events
    function openHelp() { helpModal.style.display = 'flex'; }
    function closeHelp() { helpModal.style.display = 'none'; localStorage.setItem('astar-help-seen','1'); }
    helpBtn.addEventListener('click', openHelp);
    helpClose.addEventListener('click', closeHelp);
    helpModal.addEventListener('click', (e) => { if (e.target === helpModal) closeHelp(); });

    // Fullscreen toggle
    async function enterFullscreen() {
      if (canvasWrap.requestFullscreen) await canvasWrap.requestFullscreen();
      else if (canvasWrap.webkitRequestFullscreen) await canvasWrap.webkitRequestFullscreen();
    }
    async function exitFullscreen() {
      if (document.fullscreenElement) await document.exitFullscreen();
      else if (document.webkitFullscreenElement) await document.webkitExitFullscreen();
    }
    function updateFullscreenBtn() {
      const fs = !!document.fullscreenElement || !!document.webkitFullscreenElement;
      fullscreenBtn.textContent = fs ? 'Exit Fullscreen' : 'Fullscreen';
      layoutCanvas();
      draw();
    }
    fullscreenBtn.addEventListener('click', async () => {
      const fs = !!document.fullscreenElement || !!document.webkitFullscreenElement;
      try { fs ? await exitFullscreen() : await enterFullscreen(); } catch {}
    });
    document.addEventListener('fullscreenchange', updateFullscreenBtn);
    document.addEventListener('webkitfullscreenchange', updateFullscreenBtn);

    // Resize observer to keep canvas crisp
    const ro = new ResizeObserver(() => { layoutCanvas(); draw(); });
    ro.observe(document.querySelector('.canvas-wrap'));
    window.addEventListener('resize', draw);

    // Initialize
    initGrid();
    const seen = localStorage.getItem('astar-help-seen');
    if (!seen) {
      openHelp();
      setStatus('ようこそ！まずは「Help」を確認してください。');
    } else {
      setStatus('ヒント: ドラッグで壁、ModeでStart/Goal移動。Runで探索。');
    }
  </script>
</body>
</html>
